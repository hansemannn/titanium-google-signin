/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.googlesignin

import android.app.Activity
import android.content.Intent
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.tasks.OnCompleteListener
import com.google.android.gms.tasks.Task
import org.appcelerator.kroll.KrollDict
import org.appcelerator.kroll.KrollModule
import org.appcelerator.kroll.annotations.Kroll
import org.appcelerator.kroll.annotations.Kroll.*
import org.appcelerator.kroll.common.Log
import org.appcelerator.kroll.common.TiMessenger
import org.appcelerator.titanium.TiApplication
import org.appcelerator.titanium.util.TiActivityResultHandler
import org.appcelerator.titanium.util.TiActivitySupport
import java.util.*


@module(name = "Googlesignin", id = "ti.googlesignin")
class GooglesigninModule : KrollModule() {
    private var signInClient: GoogleSignInClient? = null

    override fun onStart(activity: Activity) {
        super.onStart(activity)
        val account = GoogleSignIn.getLastSignedInAccount(TiApplication.getAppCurrentActivity())

        // Check if already logged in
        if (account != null) {
            fireLoginEvent(account)
        } else {
            signInSilently()
        }
    }

    @method
    fun initialize(opts: KrollDict) {
        if (!opts.containsKeyAndNotNull("clientID")) {
            Log.e(LCAT, "Missing required \"clientID\" property!")
            return
        }
        val options = GoogleSignInOptions.Builder(
                GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestIdToken(opts.getString("clientID"))
                .requestProfile()
                .requestEmail()
                .build()

        signInClient = GoogleSignIn.getClient(TiApplication.getAppCurrentActivity(), options)
    }

    @method
    fun hasAuthInKeychain(): Boolean {
        return GoogleSignIn.getLastSignedInAccount(TiApplication.getAppCurrentActivity()) != null
    }

    @method
    fun signIn() {
        // Building of intent
        val signInIntent = signInClient?.signInIntent ?: return
        
        val intent = Intent(TiApplication.getInstance().currentActivity, TiGoogleSignInActivity::class.java)
        intent.putExtra("google.sign.in", signInIntent)

        // building new activity with result handler
        val activitySupport = TiApplication.getInstance().currentActivity as TiActivitySupport

        if (TiApplication.isUIThread()) {
            activitySupport.launchActivityForResult(intent, RC_SIGN_IN, SignInResultHandler())
        } else {
            TiMessenger.postOnMain {
                activitySupport.launchActivityForResult(intent, RC_SIGN_IN, SignInResultHandler())
            }
        }
    }

    @method
    fun signInSilently() {
        signInClient?.silentSignIn()?.addOnCompleteListener(TiApplication.getAppCurrentActivity()) { task: Task<GoogleSignInAccount?> ->
            if (task.isSuccessful) {
                task.result?.let {
                    fireLoginEvent(it)
                }
            }
        }
    }

    @method
    fun signOut() {
        if (!hasAuthInKeychain()) {
            Log.e(LCAT, "Not currently logged in. Make sure to check with \"TiGoogleSignIn.hasAuthInKeychain()\" before calling this method");
            return
        }

        signInClient?.signOut()?.addOnCompleteListener(TiApplication.getAppCurrentActivity()) {
            if (it.isSuccessful) {
                fireEvent("logout", KrollDict())
            }
        }
    }

    @method
    fun disconnect() {
        signInClient?.revokeAccess()?.addOnCompleteListener(TiApplication.getAppCurrentActivity(), OnCompleteListener {
            if (it.isSuccessful) {
                fireEvent("disconnect", KrollDict())
            }
        })
    }

    @getProperty
    fun currentUser(): KrollDict? {
        val user = GoogleSignIn.getLastSignedInAccount(TiApplication.getAppCurrentActivity()) ?: return null
        return currentUserAsKrollDict(user)
    }
    
    private inner class SignInResultHandler : TiActivityResultHandler {
        override fun onError(activity: Activity, requestCode: Int, e: Exception) {
            fireErrorEvent(e)
        }

        override fun onResult(activity: Activity, requestCode: Int, resultCode: Int, data: Intent) {
            if (requestCode == RC_SIGN_IN) {
                Log.d(LCAT, "processing sign-in with resultCode: $resultCode")
                val task = GoogleSignIn.getSignedInAccountFromIntent(data)

                when {
                    task.isSuccessful -> {
                        val googleSignInAccount = task.result
                        googleSignInAccount?.let {
                            fireLoginEvent(it)
                        }
                    }
                    task.isCanceled -> {
                        fireCancelEvent()
                    }
                    else -> {
                        fireErrorEvent(task.exception)
                    }
                }
            }
        }
    }

    private fun fireCancelEvent() {
        val event = KrollDict()

        event["cancelled"] = true
        event["success"] = false

        fireEvent("login", event)
    }

    private fun fireErrorEvent(exception: Exception?) {
        val event = KrollDict()

        event["error"] = if (exception != null) exception.localizedMessage else "unknown exception"
        event["success"] = false

        fireEvent("error", event)
    }

    private fun fireLoginEvent(googleSignInAccount: GoogleSignInAccount) {
        val event = KrollDict()

        event["user"] = currentUserAsKrollDict(googleSignInAccount)
        event["cancelled"] = false
        event["success"] = true

        fireEvent("login", event)
    }

    private fun currentUserAsKrollDict(googleSignInAccount: GoogleSignInAccount): KrollDict {
        val user = KrollDict()
        val profile = KrollDict()
        val auth = KrollDict()
        val scopes = ArrayList<String>()

        for (scope in googleSignInAccount.grantedScopes) {
            scopes.add(scope.toString())
        }

        profile["familyName"] = googleSignInAccount.familyName
        profile["givenName"] = googleSignInAccount.givenName
        profile["accountName"] = googleSignInAccount.account?.name
        profile["name"] = googleSignInAccount.displayName
        profile["displayName"] = googleSignInAccount.displayName
        profile["email"] = googleSignInAccount.email
        profile["image"] = googleSignInAccount.photoUrl.toString()
        profile["accountType"] = googleSignInAccount.account?.type
        profile["accountString"] = googleSignInAccount.account.toString()

        auth["idToken"] = googleSignInAccount.idToken
        user["id"] = googleSignInAccount.id
        user["scopes"] = scopes.toTypedArray()
        user["serverAuthCode"] = googleSignInAccount.serverAuthCode
        user["profile"] = profile
        user["authentication"] = auth

        return user
    }

    companion object {
        const val LCAT = "TiGoogleSignIn"
        private const val RC_SIGN_IN = 9001
    }
}